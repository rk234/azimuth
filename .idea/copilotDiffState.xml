<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/kotlin/rendering/RadarSweepRenderable.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/rendering/RadarSweepRenderable.kt" />
              <option name="originalContent" value="package rendering&#10;&#10;import data.resources.ColormapManager&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.sync.Mutex&#10;import kotlinx.coroutines.sync.withLock&#10;import map.projection.MercatorProjection&#10;import map.projection.aerToGeo&#10;import meteo.radar.RadarGate&#10;import meteo.radar.RadarSweep&#10;import org.joml.Vector2f&#10;import org.lwjgl.opengl.GL45.*&#10;import org.lwjgl.system.MemoryUtil&#10;import java.nio.FloatBuffer&#10;import java.nio.IntBuffer&#10;&#10;class RadarSweepRenderable(private val sweep: RadarSweep, private val radarShader: ShaderProgram, private val cmapTexture: Texture1D) : Renderable {&#10;    private var gateCount: Int = 0&#10;    private lateinit var vbo: GLBufferObject&#10;    private lateinit var ibo: GLBufferObject&#10;    private var initialized = false&#10;&#10;    var hasGeometry = false&#10;    private lateinit var vertBuffer: FloatBuffer&#10;    private lateinit var indexBuffer: IntBuffer&#10;&#10;    private val geomMutex = Mutex()&#10;&#10;    suspend fun createGeometry() = coroutineScope {&#10;        geomMutex.withLock {&#10;            if (hasGeometry || initialized) return@coroutineScope&#10;            val jobStartIdx: IntArray = IntArray(sweep.radials.size + 1)&#10;            for ((i, radial) in sweep.radials.withIndex()) {&#10;                jobStartIdx[i] = gateCount&#10;                gateCount += radial.gates.capacity()&#10;            }&#10;            jobStartIdx[jobStartIdx.lastIndex] = gateCount&#10;&#10;            vertBuffer = MemoryUtil.memAllocFloat(gateCount * 3 * 4)&#10;            val proj = MercatorProjection()&#10;            val cmap = ColormapManager.instance.getDefault(sweep.product)&#10;&#10;            val resolution =&#10;                360.0f / sweep.radials.size&#10;            val gateSize: Float = sweep.gateWidth&#10;            val jobs = mutableListOf&lt;Deferred&lt;Unit&gt;&gt;()&#10;&#10;            val startTime = System.currentTimeMillis()&#10;            for ((i, radial) in sweep.radials.withIndex()) {&#10;                jobs.add(async(Dispatchers.Default) {&#10;                    val azimuth = radial.azimuth&#10;                    val startAngle: Float = (azimuth) - (resolution / 2) * 1.12f&#10;                    val endAngle: Float = (azimuth) + (resolution / 2) * 1.12f&#10;                    val quad = FloatArray(12)&#10;                    for (gateIndex in jobStartIdx[i]..&lt;jobStartIdx[i + 1]) {&#10;                        val gate = RadarGate(radial.gates.get(gateIndex - jobStartIdx[i]))&#10;                        val range = sweep.rangeStart + (gateSize * gate.idx().toFloat()) // 1000&#10;                        val data = gate.scaledValue(sweep.scale, sweep.addOffset)&#10;&#10;                        val rescaled = cmap.rescale(data)&#10;                        val gateVertIndex = gateIndex * 4 * 3&#10;                        vertBuffer.put(gateVertIndex, startAngle)&#10;                        vertBuffer.put(gateVertIndex+1,range)&#10;                        vertBuffer.put(gateVertIndex+2, rescaled)&#10;&#10;                        vertBuffer.put(gateVertIndex+3,startAngle)&#10;                        vertBuffer.put(range+gateSize)&#10;                        vertBuffer.put(rescaled)&#10;&#10;                        vertBuffer.put(endAngle)&#10;                        vertBuffer.put(range+gateSize)&#10;                        vertBuffer.put(rescaled)&#10;&#10;                        vertBuffer.put(endAngle)&#10;                        vertBuffer.put(range)&#10;                        vertBuffer.put(rescaled)&#10;&#10;                        vertBuffer.put(gateVertIndex, quad)&#10;                    }&#10;                })&#10;            }&#10;&#10;            jobs.awaitAll()&#10;&#10;            val dur = System.currentTimeMillis() - startTime&#10;            println(&quot;VERT GEN: ${dur}ms&quot;)&#10;//        vertBuffer.flip()&#10;&#10;            val iboGenStart = System.currentTimeMillis()&#10;            indexBuffer = MemoryUtil.memAllocInt(gateCount * 6)&#10;&#10;            indexBuffer = MemoryUtil.memAllocInt((gateCount) * 6)&#10;            generateIndices(indexBuffer, gateCount)&#10;            indexBuffer.flip()&#10;            println(&quot;IBO GEN: ${System.currentTimeMillis() - iboGenStart}ms&quot;)&#10;            hasGeometry = true&#10;        }&#10;    }&#10;&#10;    override fun init(vaoContext: VAOContext) {&#10;        if(initialized) return&#10;        if(!hasGeometry) {&#10;            runBlocking {&#10;                createGeometry()&#10;            }&#10;        }&#10;&#10;        val vao = vaoContext.getVAO(this)&#10;        vao.bind()&#10;&#10;        vbo = GLBufferObject()&#10;        vbo.bind()&#10;        vbo.uploadData(vertBuffer, GL_STATIC_DRAW)&#10;        MemoryUtil.memFree(vertBuffer)&#10;&#10;        vao.attrib(0, 2, GL_FLOAT, false, 3 * Float.SIZE_BYTES, 0)&#10;        vao.attrib(1, 1, GL_FLOAT, false, 3 * Float.SIZE_BYTES, (2 * Float.SIZE_BYTES).toLong())&#10;&#10;        vao.enableAttrib(0)&#10;        vao.enableAttrib(1)&#10;&#10;        ibo = GLBufferObject(GL_ELEMENT_ARRAY_BUFFER)&#10;        ibo.bind()&#10;&#10;        ibo.uploadData(indexBuffer, GL_STATIC_DRAW)&#10;        MemoryUtil.memFree(indexBuffer)&#10;        initialized = true&#10;        hasGeometry = false&#10;    }&#10;&#10;    override fun draw(camera: Camera, vaoContext: VAOContext) {&#10;        radarShader.bind()&#10;        radarShader.setUniformMatrix4f(&quot;projectionMatrix&quot;, camera.projectionMatrix)&#10;        radarShader.setUniformMatrix4f(&quot;transformMatrix&quot;, camera.transformMatrix)&#10;        radarShader.setUniformVec2f(&quot;stationLatLon&quot;, Vector2f(sweep.station.latitude, sweep.station.longitude))&#10;        radarShader.setUniformFloat(&quot;elevation&quot;, sweep.elevation)&#10;&#10;        cmapTexture.bind()&#10;        val vao = vaoContext.getVAO(this) { vao -&gt;&#10;            vao.bind()&#10;            vbo.bind()&#10;&#10;            vao.attrib(0, 2, GL_FLOAT, false, 3 * Float.SIZE_BYTES, 0)&#10;            vao.attrib(1, 1, GL_FLOAT, false, 3 * Float.SIZE_BYTES, (2 * Float.SIZE_BYTES).toLong())&#10;&#10;            vao.enableAttrib(0)&#10;            vao.enableAttrib(1)&#10;&#10;            ibo.bind()&#10;        }&#10;        vao.bind()&#10;        glDrawElements(GL_TRIANGLES, gateCount * 6, GL_UNSIGNED_INT, 0)&#10;    }&#10;&#10;    override fun destroy() {&#10;        if(initialized) {&#10;            //TODO pass vao context here&#10;//        vao.destroy()&#10;            vbo.destroy()&#10;            ibo.destroy()&#10;        }&#10;    }&#10;    //TODO: can pre-compute these indices&#10;    private fun generateIndices(indices: IntBuffer, gateCount: Int) {&#10;        var index = 0&#10;        for (j in 0..&lt;gateCount) {&#10;            val i = index&#10;            indices.put(i)&#10;            indices.put(i + 1)&#10;            indices.put(i + 2)&#10;            indices.put(i + 2)&#10;            indices.put(i + 3)&#10;            indices.put(i)&#10;            index += 4&#10;        }&#10;    }&#10;&#10;    fun initialized(): Boolean {&#10;        return initialized&#10;    }&#10;}" />
              <option name="updatedContent" value="package rendering&#10;&#10;import data.resources.ColormapManager&#10;import kotlinx.coroutines.*&#10;import kotlinx.coroutines.sync.Mutex&#10;import kotlinx.coroutines.sync.withLock&#10;import map.projection.MercatorProjection&#10;import map.projection.aerToGeo&#10;import meteo.radar.RadarGate&#10;import meteo.radar.RadarSweep&#10;import org.joml.Vector2f&#10;import org.lwjgl.opengl.GL45.*&#10;import org.lwjgl.system.MemoryUtil&#10;import java.nio.FloatBuffer&#10;import java.nio.IntBuffer&#10;&#10;class RadarSweepRenderable(private val sweep: RadarSweep, private val radarShader: ShaderProgram, private val cmapTexture: Texture1D) : Renderable {&#10;    private var gateCount: Int = 0&#10;    private lateinit var vbo: GLBufferObject&#10;    private lateinit var ibo: GLBufferObject&#10;    private var initialized = false&#10;&#10;    var hasGeometry = false&#10;    private lateinit var vertBuffer: FloatBuffer&#10;    private lateinit var indexBuffer: IntBuffer&#10;&#10;    private val geomMutex = Mutex()&#10;&#10;    suspend fun createGeometry() = coroutineScope {&#10;        geomMutex.withLock {&#10;            if (hasGeometry || initialized) return@coroutineScope&#10;            val jobStartIdx: IntArray = IntArray(sweep.radials.size + 1)&#10;            for ((i, radial) in sweep.radials.withIndex()) {&#10;                jobStartIdx[i] = gateCount&#10;                gateCount += radial.gates.capacity()&#10;            }&#10;            jobStartIdx[jobStartIdx.lastIndex] = gateCount&#10;&#10;            vertBuffer = MemoryUtil.memAllocFloat(gateCount * 3 * 4)&#10;            val proj = MercatorProjection()&#10;            val cmap = ColormapManager.instance.getDefault(sweep.product)&#10;&#10;            val resolution =&#10;                360.0f / sweep.radials.size&#10;            val gateSize: Float = sweep.gateWidth&#10;            val jobs = mutableListOf&lt;Deferred&lt;Unit&gt;&gt;()&#10;&#10;            val startTime = System.currentTimeMillis()&#10;            for ((i, radial) in sweep.radials.withIndex()) {&#10;                jobs.add(async(Dispatchers.Default) {&#10;                    val azimuth = radial.azimuth&#10;                    val startAngle: Float = (azimuth) - (resolution / 2) * 1.12f&#10;                    val endAngle: Float = (azimuth) + (resolution / 2) * 1.12f&#10;                    for (gateIndex in jobStartIdx[i]..&lt;jobStartIdx[i + 1]) {&#10;                        val gate = RadarGate(radial.gates.get(gateIndex - jobStartIdx[i]))&#10;                        val range = sweep.rangeStart + (gateSize * gate.idx().toFloat())&#10;                        val data = gate.scaledValue(sweep.scale, sweep.addOffset)&#10;&#10;                        val rescaled = cmap.rescale(data)&#10;                        val gateVertIndex = gateIndex * 4 * 3&#10;&#10;                        // Vertex 0&#10;                        vertBuffer.put(gateVertIndex, startAngle)&#10;                        vertBuffer.put(gateVertIndex + 1, range)&#10;                        vertBuffer.put(gateVertIndex + 2, rescaled)&#10;                        // Vertex 1&#10;                        vertBuffer.put(gateVertIndex + 3, startAngle)&#10;                        vertBuffer.put(gateVertIndex + 4, range + gateSize)&#10;                        vertBuffer.put(gateVertIndex + 5, rescaled)&#10;                        // Vertex 2&#10;                        vertBuffer.put(gateVertIndex + 6, endAngle)&#10;                        vertBuffer.put(gateVertIndex + 7, range + gateSize)&#10;                        vertBuffer.put(gateVertIndex + 8, rescaled)&#10;                        // Vertex 3&#10;                        vertBuffer.put(gateVertIndex + 9, endAngle)&#10;                        vertBuffer.put(gateVertIndex + 10, range)&#10;                        vertBuffer.put(gateVertIndex + 11, rescaled)&#10;                    }&#10;                })&#10;            }&#10;&#10;            jobs.awaitAll()&#10;&#10;            val dur = System.currentTimeMillis() - startTime&#10;            println(&quot;VERT GEN: ${dur}ms&quot;)&#10;//        vertBuffer.flip()&#10;&#10;            val iboGenStart = System.currentTimeMillis()&#10;            indexBuffer = MemoryUtil.memAllocInt(gateCount * 6)&#10;&#10;            indexBuffer = MemoryUtil.memAllocInt((gateCount) * 6)&#10;            generateIndices(indexBuffer, gateCount)&#10;            indexBuffer.flip()&#10;            println(&quot;IBO GEN: ${System.currentTimeMillis() - iboGenStart}ms&quot;)&#10;            hasGeometry = true&#10;        }&#10;    }&#10;&#10;    override fun init(vaoContext: VAOContext) {&#10;        if(initialized) return&#10;        if(!hasGeometry) {&#10;            runBlocking {&#10;                createGeometry()&#10;            }&#10;        }&#10;&#10;        val vao = vaoContext.getVAO(this)&#10;        vao.bind()&#10;&#10;        vbo = GLBufferObject()&#10;        vbo.bind()&#10;        vbo.uploadData(vertBuffer, GL_STATIC_DRAW)&#10;        MemoryUtil.memFree(vertBuffer)&#10;&#10;        vao.attrib(0, 2, GL_FLOAT, false, 3 * Float.SIZE_BYTES, 0)&#10;        vao.attrib(1, 1, GL_FLOAT, false, 3 * Float.SIZE_BYTES, (2 * Float.SIZE_BYTES).toLong())&#10;&#10;        vao.enableAttrib(0)&#10;        vao.enableAttrib(1)&#10;&#10;        ibo = GLBufferObject(GL_ELEMENT_ARRAY_BUFFER)&#10;        ibo.bind()&#10;&#10;        ibo.uploadData(indexBuffer, GL_STATIC_DRAW)&#10;        MemoryUtil.memFree(indexBuffer)&#10;        initialized = true&#10;        hasGeometry = false&#10;    }&#10;&#10;    override fun draw(camera: Camera, vaoContext: VAOContext) {&#10;        radarShader.bind()&#10;        radarShader.setUniformMatrix4f(&quot;projectionMatrix&quot;, camera.projectionMatrix)&#10;        radarShader.setUniformMatrix4f(&quot;transformMatrix&quot;, camera.transformMatrix)&#10;        radarShader.setUniformVec2f(&quot;stationLatLon&quot;, Vector2f(sweep.station.latitude, sweep.station.longitude))&#10;        radarShader.setUniformFloat(&quot;elevation&quot;, sweep.elevation)&#10;&#10;        cmapTexture.bind()&#10;        val vao = vaoContext.getVAO(this) { vao -&gt;&#10;            vao.bind()&#10;            vbo.bind()&#10;&#10;            vao.attrib(0, 2, GL_FLOAT, false, 3 * Float.SIZE_BYTES, 0)&#10;            vao.attrib(1, 1, GL_FLOAT, false, 3 * Float.SIZE_BYTES, (2 * Float.SIZE_BYTES).toLong())&#10;&#10;            vao.enableAttrib(0)&#10;            vao.enableAttrib(1)&#10;&#10;            ibo.bind()&#10;        }&#10;        vao.bind()&#10;        glDrawElements(GL_TRIANGLES, gateCount * 6, GL_UNSIGNED_INT, 0)&#10;    }&#10;&#10;    override fun destroy() {&#10;        if(initialized) {&#10;            //TODO pass vao context here&#10;//        vao.destroy()&#10;            vbo.destroy()&#10;            ibo.destroy()&#10;        }&#10;    }&#10;    //TODO: can pre-compute these indices&#10;    private fun generateIndices(indices: IntBuffer, gateCount: Int) {&#10;        var index = 0&#10;        for (j in 0..&lt;gateCount) {&#10;            val i = index&#10;            indices.put(i)&#10;            indices.put(i + 1)&#10;            indices.put(i + 2)&#10;            indices.put(i + 2)&#10;            indices.put(i + 3)&#10;            indices.put(i)&#10;            index += 4&#10;        }&#10;    }&#10;&#10;    fun initialized(): Boolean {&#10;        return initialized&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/views/sidebar/SideBar.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/views/sidebar/SideBar.kt" />
              <option name="originalContent" value="package views.sidebar&#10;&#10;import views.PaneLayout&#10;import java.awt.Dimension&#10;import javax.swing.*&#10;&#10;class SideBar : JPanel() {&#10;    val radarPanel: RadarPanel&#10;&#10;&#10;    init {&#10;        layout = BoxLayout(this, BoxLayout.Y_AXIS)&#10;        preferredSize = Dimension(400, 300)&#10;&#10;        val stationPanel = StationPanel()&#10;        stationPanel.alignmentX = JPanel.LEFT_ALIGNMENT&#10;        add(stationPanel)&#10;&#10;        val tabs = JTabbedPane()&#10;&#10;        radarPanel = RadarPanel()&#10;&#10;        tabs.addTab(&quot;Radar&quot;, radarPanel)&#10;        val mockWarnings = listOf(&#10;            data.warnings.Warning(&#10;                name = &quot;Tornado Warning&quot;,&#10;                message = &quot;A tornado is imminent. Take shelter now!&quot;,&#10;                areaDesc = &quot;Central County&quot;,&#10;                sent = java.time.ZonedDateTime.now(),&#10;                effective = java.time.ZonedDateTime.now(),&#10;                onset = java.time.ZonedDateTime.now(),&#10;                expires = java.time.ZonedDateTime.now().plusHours(1)&#10;            ),&#10;            data.warnings.Warning(&#10;                name = &quot;Severe Thunderstorm Warning&quot;,&#10;                message = &quot;Severe thunderstorm with large hail and damaging winds.&quot;,&#10;                areaDesc = &quot;East County&quot;,&#10;                sent = java.time.ZonedDateTime.now(),&#10;                effective = java.time.ZonedDateTime.now(),&#10;                onset = java.time.ZonedDateTime.now(),&#10;                expires = java.time.ZonedDateTime.now().plusHours(2)&#10;            ),&#10;            data.warnings.Warning(&#10;                name = &quot;Flash Flood Warning&quot;,&#10;                message = &quot;Flash flooding is already occurring or imminent.&quot;,&#10;                areaDesc = &quot;West County&quot;,&#10;                sent = java.time.ZonedDateTime.now(),&#10;                effective = java.time.ZonedDateTime.now(),&#10;                onset = java.time.ZonedDateTime.now(),&#10;                expires = java.time.ZonedDateTime.now().plusHours(3)&#10;            )&#10;        ).flatMap { warning -&gt;&#10;            listOf(&#10;                warning.copy(name = &quot;Tornado Warning&quot;, message = &quot;Tornado warning for ${warning.areaDesc}&quot;),&#10;                warning.copy(&#10;                    name = &quot;Severe Thunderstorm Warning&quot;,&#10;                    message = &quot;Severe thunderstorm warning for ${warning.areaDesc}&quot;&#10;                ),&#10;                warning.copy(name = &quot;Flash Flood Warning&quot;, message = &quot;Flash flood warning for ${warning.areaDesc}&quot;)&#10;            )&#10;        }&#10;        tabs.addTab(&quot;Warnings&quot;, WarningPanel(mockWarnings))&#10;        tabs.addTab(&quot;Map&quot;, JLabel(&quot;Map tab&quot;))&#10;&#10;        tabs.alignmentX = JTabbedPane.LEFT_ALIGNMENT&#10;        add(tabs)&#10;    }&#10;&#10;    fun onPaneLayoutChange(listener: (PaneLayout) -&gt; Unit) {&#10;        radarPanel.addPaneLayoutChangeListener(listener)&#10;    }&#10;}" />
              <option name="updatedContent" value="package views.sidebar&#10;&#10;import views.PaneLayout&#10;import java.awt.Dimension&#10;import javax.swing.*&#10;&#10;class SideBar : JPanel() {&#10;    val radarPanel: RadarPanel&#10;&#10;&#10;    init {&#10;        layout = BoxLayout(this, BoxLayout.Y_AXIS)&#10;        preferredSize = Dimension(400, 300)&#10;&#10;        val stationPanel = StationPanel()&#10;        stationPanel.alignmentX = JPanel.LEFT_ALIGNMENT&#10;        add(stationPanel)&#10;&#10;        val tabs = JTabbedPane()&#10;&#10;        radarPanel = RadarPanel()&#10;&#10;        tabs.addTab(&quot;Radar&quot;, radarPanel)&#10;        val mockWarnings = listOf(&#10;            data.warnings.Warning(&#10;                name = &quot;Tornado Warning&quot;,&#10;                type = data.warnings.WarningType.TORNADO,&#10;                message = &quot;A tornado is imminent. Take shelter now!&quot;,&#10;                areaDesc = &quot;Central County&quot;,&#10;                sent = java.time.ZonedDateTime.now(),&#10;                effective = java.time.ZonedDateTime.now(),&#10;                onset = java.time.ZonedDateTime.now(),&#10;                expires = java.time.ZonedDateTime.now().plusHours(1),&#10;                polygons = emptyList()&#10;            ),&#10;            data.warnings.Warning(&#10;                name = &quot;Severe Thunderstorm Warning&quot;,&#10;                type = data.warnings.WarningType.SEVERE_THUNDERSTORM,&#10;                message = &quot;Severe thunderstorm with large hail and damaging winds.&quot;,&#10;                areaDesc = &quot;East County&quot;,&#10;                sent = java.time.ZonedDateTime.now(),&#10;                effective = java.time.ZonedDateTime.now(),&#10;                onset = java.time.ZonedDateTime.now(),&#10;                expires = java.time.ZonedDateTime.now().plusHours(2),&#10;                polygons = emptyList()&#10;            ),&#10;            data.warnings.Warning(&#10;                name = &quot;Flash Flood Warning&quot;,&#10;                type = data.warnings.WarningType.FLASH_FLOOD,&#10;                message = &quot;Flash flooding is already occurring or imminent.&quot;,&#10;                areaDesc = &quot;West County&quot;,&#10;                sent = java.time.ZonedDateTime.now(),&#10;                effective = java.time.ZonedDateTime.now(),&#10;                onset = java.time.ZonedDateTime.now(),&#10;                expires = java.time.ZonedDateTime.now().plusHours(3),&#10;                polygons = emptyList()&#10;            )&#10;        ).flatMap { warning -&gt;&#10;            listOf(&#10;                warning.copy(&#10;                    name = &quot;Tornado Warning&quot;,&#10;                    message = &quot;Tornado warning for ${warning.areaDesc}&quot;,&#10;                    type = data.warnings.WarningType.TORNADO&#10;                ),&#10;                warning.copy(&#10;                    name = &quot;Severe Thunderstorm Warning&quot;,&#10;                    message = &quot;Severe thunderstorm warning for ${warning.areaDesc}&quot;,&#10;                    type = data.warnings.WarningType.SEVERE_THUNDERSTORM&#10;                ),&#10;                warning.copy(&#10;                    name = &quot;Flash Flood Warning&quot;,&#10;                    message = &quot;Flash flood warning for ${warning.areaDesc}&quot;,&#10;                    type = data.warnings.WarningType.FLASH_FLOOD&#10;                )&#10;            )&#10;        }&#10;        tabs.addTab(&quot;Warnings&quot;, WarningPanel(mockWarnings))&#10;        tabs.addTab(&quot;Map&quot;, JLabel(&quot;Map tab&quot;))&#10;&#10;        tabs.alignmentX = JTabbedPane.LEFT_ALIGNMENT&#10;        add(tabs)&#10;    }&#10;&#10;    fun onPaneLayoutChange(listener: (PaneLayout) -&gt; Unit) {&#10;        radarPanel.addPaneLayoutChangeListener(listener)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/views/sidebar/WarningPanel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/views/sidebar/WarningPanel.kt" />
              <option name="originalContent" value="package views.sidebar&#10;&#10;import data.state.AppState&#10;import data.warnings.Warning&#10;import java.awt.*&#10;import java.time.Duration&#10;import java.time.ZonedDateTime&#10;import java.time.format.DateTimeFormatter&#10;import javax.swing.*&#10;import javax.swing.border.EmptyBorder&#10;&#10;class WarningPanel(private val warnings: MutableList&lt;Warning&gt;) : JScrollPane() {&#10;&#10;    private val panel = JPanel()&#10;&#10;    init {&#10;        AppState.warningDataManager.addListener {&#10;            println(&quot;New warnings received: ${it.size}&quot;)&#10;            warnings.clear()&#10;            warnings.addAll(it)&#10;        }&#10;&#10;        panel.layout = BoxLayout(panel, BoxLayout.Y_AXIS)&#10;        panel.background = UIManager.getColor(&quot;List.background&quot;)&#10;        setViewportView(panel)&#10;        verticalScrollBarPolicy = VERTICAL_SCROLLBAR_AS_NEEDED&#10;        horizontalScrollBarPolicy = HORIZONTAL_SCROLLBAR_NEVER&#10;        border = BorderFactory.createEmptyBorder()&#10;&#10;        verticalScrollBar.unitIncrement = 10&#10;&#10;        if (warnings.isEmpty()) {&#10;            val noWarningsLabel = JLabel(&quot;No active warnings&quot;).apply {&#10;                horizontalAlignment = SwingConstants.CENTER&#10;                foreground = Color.GRAY&#10;            }&#10;            val centerPanel = JPanel(GridBagLayout())&#10;            centerPanel.add(noWarningsLabel)&#10;            panel.add(centerPanel)&#10;        } else {&#10;            warnings.forEach { warning -&gt;&#10;                val item = WarningItem(warning)&#10;                // Add mouse listener for popup&#10;                item.addMouseListener(object : java.awt.event.MouseAdapter() {&#10;                    override fun mouseClicked(e: java.awt.event.MouseEvent?) {&#10;                        WarningPopup.show(warning)&#10;                    }&#10;                })&#10;                panel.add(item)&#10;                panel.add(Box.createRigidArea(Dimension(0, 5))) // separator&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;class WarningItem(warning: Warning) : JPanel() {&#10;&#10;    private val expiresLabel: JLabel&#10;&#10;    init {&#10;        layout = BorderLayout(10, 0)&#10;        border = EmptyBorder(5, 0, 5, 10)&#10;        alignmentX = LEFT_ALIGNMENT&#10;&#10;        val borderColor = when (warning.name) {&#10;            &quot;Tornado Warning&quot; -&gt; Color.RED&#10;            &quot;Severe Thunderstorm Warning&quot; -&gt; Color.ORANGE&#10;            &quot;Flash Flood Warning&quot; -&gt; Color.GREEN&#10;            else -&gt; Color.GRAY&#10;        }&#10;&#10;        val colorStripe = JPanel().apply {&#10;            background = borderColor&#10;            preferredSize = Dimension(5, 0)&#10;        }&#10;        add(colorStripe, BorderLayout.WEST)&#10;&#10;        val textPanel = JPanel().apply {&#10;            layout = BoxLayout(this, BoxLayout.Y_AXIS)&#10;            isOpaque = false&#10;        }&#10;&#10;        val typeLabel = JLabel(warning.name).apply {&#10;            putClientProperty(&quot;FlatLaf.styleClass&quot;, &quot;h3&quot;)&#10;            alignmentX = JLabel.LEFT_ALIGNMENT&#10;        }&#10;        val messageLabel = JTextArea(warning.headline).apply {&#10;            putClientProperty(&quot;FlatLaf.styleClass&quot;, &quot;p&quot;)&#10;            wrapStyleWord = true&#10;            lineWrap = true&#10;            isOpaque = false&#10;            isEditable = false&#10;            isFocusable = false&#10;            background = UIManager.getColor(&quot;Label.background&quot;)&#10;            foreground = UIManager.getColor(&quot;Label.foreground&quot;)&#10;            border = UIManager.getBorder(&quot;Label.border&quot;)&#10;            alignmentX = JLabel.LEFT_ALIGNMENT&#10;        }&#10;&#10;        expiresLabel = JLabel().apply {&#10;            alignmentX = JLabel.LEFT_ALIGNMENT&#10;        }&#10;        updateExpiresLabel(warning)&#10;&#10;        // Timer to update the label every second&#10;        val timer = Timer(1000) {&#10;            updateExpiresLabel(warning)&#10;        }&#10;        timer.start()&#10;&#10;        textPanel.add(typeLabel)&#10;        textPanel.add(Box.createRigidArea(Dimension(0, 2)))&#10;        textPanel.add(messageLabel)&#10;        textPanel.add(Box.createRigidArea(Dimension(0, 5)))&#10;        textPanel.add(expiresLabel)&#10;        add(textPanel, BorderLayout.CENTER)&#10;&#10;        val iconLabel = JLabel(UIManager.getIcon(&quot;OptionPane.warningIcon&quot;))&#10;        add(iconLabel, BorderLayout.EAST)&#10;    }&#10;&#10;    private fun updateExpiresLabel(warning: Warning) {&#10;        val now = ZonedDateTime.now()&#10;        val expires = warning.expires&#10;        val duration = Duration.between(now, expires)&#10;        val seconds = duration.seconds&#10;        val label = if (seconds &gt; 0) {&#10;            val hours = seconds / 3600&#10;            val minutes = (seconds % 3600) / 60&#10;            val secs = seconds % 60&#10;            buildString {&#10;                append(&quot;Expires in &quot;)&#10;                if (hours &gt; 0) append(&quot;${hours}h &quot;)&#10;                if (minutes &gt; 0 || hours &gt; 0) append(&quot;${minutes}m &quot;)&#10;                append(&quot;${secs}s&quot;)&#10;            }&#10;        } else {&#10;            &quot;Expired!&quot;&#10;        }&#10;        expiresLabel.text = label&#10;    }&#10;&#10;    override fun getMaximumSize(): Dimension {&#10;        val preferred = preferredSize&#10;        return Dimension(Integer.MAX_VALUE, preferred.height)&#10;    }&#10;}&#10;&#10;// Add this class at the end of the file&#10;object WarningPopup {&#10;    fun show(warning: Warning) {&#10;        val frame = JFrame(warning.name)&#10;        frame.defaultCloseOperation = JFrame.DISPOSE_ON_CLOSE&#10;        frame.layout = BorderLayout()&#10;        frame.isAlwaysOnTop = true&#10;&#10;        // Header panel (reuse WarningItem, but disable mouse interaction)&#10;        val header = WarningItem(warning)&#10;        header.isEnabled = false&#10;&#10;        // Full message area&#10;        val textArea = JTextArea(warning.message).apply {&#10;            lineWrap = true&#10;            wrapStyleWord = true&#10;            isEditable = false&#10;            isFocusable = false&#10;            border = BorderFactory.createEmptyBorder(10, 10, 10, 10)&#10;        }&#10;&#10;        frame.add(header, BorderLayout.NORTH)&#10;        frame.add(JScrollPane(textArea), BorderLayout.CENTER)&#10;        frame.setSize(400, 300)&#10;        frame.setLocationRelativeTo(null)&#10;        frame.isVisible = true&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package views.sidebar&#10;&#10;import data.state.AppState&#10;import data.warnings.Warning&#10;import java.awt.*&#10;import java.time.Duration&#10;import java.time.ZonedDateTime&#10;import java.time.format.DateTimeFormatter&#10;import javax.swing.*&#10;import javax.swing.border.EmptyBorder&#10;&#10;class WarningPanel(private val warnings: MutableList&lt;Warning&gt;) : JScrollPane() {&#10;&#10;    private val panel = JPanel()&#10;&#10;    init {&#10;        AppState.warningDataManager.addListener {&#10;            println(&quot;New warnings received: ${it.size}&quot;)&#10;            warnings.clear()&#10;            warnings.addAll(it)&#10;        }&#10;&#10;        panel.layout = BoxLayout(panel, BoxLayout.Y_AXIS)&#10;        panel.background = UIManager.getColor(&quot;List.background&quot;)&#10;        setViewportView(panel)&#10;        verticalScrollBarPolicy = VERTICAL_SCROLLBAR_AS_NEEDED&#10;        horizontalScrollBarPolicy = HORIZONTAL_SCROLLBAR_NEVER&#10;        border = BorderFactory.createEmptyBorder()&#10;&#10;        verticalScrollBar.unitIncrement = 10&#10;&#10;        if (warnings.isEmpty()) {&#10;            val noWarningsLabel = JLabel(&quot;No active warnings&quot;).apply {&#10;                horizontalAlignment = SwingConstants.CENTER&#10;                foreground = Color.GRAY&#10;            }&#10;            val centerPanel = JPanel(GridBagLayout())&#10;            centerPanel.add(noWarningsLabel)&#10;            panel.add(centerPanel)&#10;        } else {&#10;            warnings.forEach { warning -&gt;&#10;                val item = WarningItem(warning)&#10;                // Add mouse listener for popup&#10;                item.addMouseListener(object : java.awt.event.MouseAdapter() {&#10;                    override fun mouseClicked(e: java.awt.event.MouseEvent?) {&#10;                        WarningPopup.show(warning)&#10;                    }&#10;                })&#10;                panel.add(item)&#10;                panel.add(Box.createRigidArea(Dimension(0, 5))) // separator&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;class WarningItem(warning: Warning) : JPanel() {&#10;&#10;    private val expiresLabel: JLabel&#10;&#10;    init {&#10;        layout = BorderLayout(10, 0)&#10;        border = EmptyBorder(5, 0, 5, 10)&#10;        alignmentX = LEFT_ALIGNMENT&#10;&#10;        val borderColor = when (warning.name) {&#10;            &quot;Tornado Warning&quot; -&gt; Color.RED&#10;            &quot;Severe Thunderstorm Warning&quot; -&gt; Color.ORANGE&#10;            &quot;Flash Flood Warning&quot; -&gt; Color.GREEN&#10;            else -&gt; Color.GRAY&#10;        }&#10;&#10;        val colorStripe = JPanel().apply {&#10;            background = borderColor&#10;            preferredSize = Dimension(5, 0)&#10;        }&#10;        add(colorStripe, BorderLayout.WEST)&#10;&#10;        val textPanel = JPanel().apply {&#10;            layout = BoxLayout(this, BoxLayout.Y_AXIS)&#10;            isOpaque = false&#10;        }&#10;&#10;        val typeLabel = JLabel(warning.name).apply {&#10;            putClientProperty(&quot;FlatLaf.styleClass&quot;, &quot;h3&quot;)&#10;            alignmentX = JLabel.LEFT_ALIGNMENT&#10;        }&#10;        val messageLabel = JTextArea(warning.headline).apply {&#10;            putClientProperty(&quot;FlatLaf.styleClass&quot;, &quot;p&quot;)&#10;            wrapStyleWord = true&#10;            lineWrap = true&#10;            isOpaque = false&#10;            isEditable = false&#10;            isFocusable = false&#10;            background = UIManager.getColor(&quot;Label.background&quot;)&#10;            foreground = UIManager.getColor(&quot;Label.foreground&quot;)&#10;            border = UIManager.getBorder(&quot;Label.border&quot;)&#10;            alignmentX = JLabel.LEFT_ALIGNMENT&#10;        }&#10;&#10;        expiresLabel = JLabel().apply {&#10;            alignmentX = JLabel.LEFT_ALIGNMENT&#10;            // Set tooltip with expiry time in local timezone&#10;            toolTipText = &quot;Expires at: &quot; + warning.expires.withZoneSameInstant(java.time.ZoneId.systemDefault())&#10;                .format(java.time.format.DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss z&quot;))&#10;        }&#10;        updateExpiresLabel(warning)&#10;&#10;        // Timer to update the label every second&#10;        val timer = Timer(1000) {&#10;            updateExpiresLabel(warning)&#10;        }&#10;        timer.start()&#10;&#10;        textPanel.add(typeLabel)&#10;        textPanel.add(Box.createRigidArea(Dimension(0, 2)))&#10;        textPanel.add(messageLabel)&#10;        textPanel.add(Box.createRigidArea(Dimension(0, 5)))&#10;        textPanel.add(expiresLabel)&#10;        add(textPanel, BorderLayout.CENTER)&#10;&#10;        val iconLabel = JLabel(UIManager.getIcon(&quot;OptionPane.warningIcon&quot;))&#10;        add(iconLabel, BorderLayout.EAST)&#10;    }&#10;&#10;    private fun updateExpiresLabel(warning: Warning) {&#10;        val now = ZonedDateTime.now()&#10;        val expires = warning.expires&#10;        val duration = Duration.between(now, expires)&#10;        val seconds = duration.seconds&#10;        val label = if (seconds &gt; 0) {&#10;            val hours = seconds / 3600&#10;            val minutes = (seconds % 3600) / 60&#10;            val secs = seconds % 60&#10;            buildString {&#10;                append(&quot;Expires in &quot;)&#10;                if (hours &gt; 0) append(&quot;${hours}h &quot;)&#10;                if (minutes &gt; 0 || hours &gt; 0) append(&quot;${minutes}m &quot;)&#10;                append(&quot;${secs}s&quot;)&#10;            }&#10;        } else {&#10;            &quot;Expired!&quot;&#10;        }&#10;        expiresLabel.text = label&#10;    }&#10;&#10;    override fun getMaximumSize(): Dimension {&#10;        val preferred = preferredSize&#10;        return Dimension(Integer.MAX_VALUE, preferred.height)&#10;    }&#10;}&#10;&#10;// Add this class at the end of the file&#10;object WarningPopup {&#10;    fun show(warning: Warning) {&#10;        val frame = JFrame(warning.name)&#10;        frame.defaultCloseOperation = JFrame.DISPOSE_ON_CLOSE&#10;        frame.layout = BorderLayout()&#10;        frame.isAlwaysOnTop = true&#10;&#10;        // Header panel (reuse WarningItem, but disable mouse interaction)&#10;        val header = WarningItem(warning)&#10;        header.isEnabled = false&#10;&#10;        // Full message area&#10;        val textArea = JTextArea(warning.message).apply {&#10;            lineWrap = true&#10;            wrapStyleWord = true&#10;            isEditable = false&#10;            isFocusable = false&#10;            border = BorderFactory.createEmptyBorder(10, 10, 10, 10)&#10;        }&#10;&#10;        frame.add(header, BorderLayout.NORTH)&#10;        frame.add(JScrollPane(textArea), BorderLayout.CENTER)&#10;        frame.setSize(400, 300)&#10;        frame.setLocationRelativeTo(null)&#10;        frame.isVisible = true&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>